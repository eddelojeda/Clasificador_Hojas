# -*- coding: utf-8 -*-
"""Copy of Leafs plants.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14eAK3hxD1JDrxPtsdTEg_pDNZOxzaBhZ

#Enfermedades de plantas

https://www.tensorflow.org/datasets/catalog/plant_leaves?hl=es-419
"""

import numpy as np
import tensorflow as tf
import matplotlib.pyplot as plt
import tensorflow_datasets as tfds
from tensorflow.keras import layers, models
from tensorflow.keras.callbacks import EarlyStopping
from tensorflow.keras.applications import MobileNetV2
from tensorflow.keras.applications.mobilenet_v2 import preprocess_input
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay, roc_curve, auc, classification_report
from sklearn.preprocessing import label_binarize

# Commented out IPython magic to ensure Python compatibility.
# Cargar el dataset
dataset, info = tfds.load('plant_leaves', split='train', with_info=True, as_supervised=True)

len(dataset)

labels = []
for example in dataset:
    labels.append(example[1].numpy())

unique_elements, count_elements = np.unique(labels,return_counts=True)
print(unique_elements)
print(count_elements)

# Histograma de porcentajes del dataset de cada clase
percentages = (count_elements / np.sum(count_elements)) * 100
plt.figure(figsize=(10, 6))
plt.bar(unique_elements.astype(str), percentages, color='b') 
plt.xlabel('Class', fontsize=12)
plt.ylabel('Percentage (%)', fontsize=12)
plt.title('Class distribution', fontsize=14)
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.savefig('Hojas_enfermas/Class_percentages.jpg')
plt.close()

# Iterar sobre el dataset
for example in dataset.take(5):
    image = example[0]
    label = example[1]
    print(image.shape, label.numpy())

# Visualizar las im치genes
sample = dataset.take(18)
fig = plt.figure(figsize=(18, 9))
for i, example in enumerate(sample):
    image = example[0]
    label = example[1]
    label_name = info.features['label'].int2str(label.numpy())

    ax = fig.add_subplot(3, 6, i + 1)
    ax.imshow(image)
    ax.set_title(label_name, fontsize=10)
    ax.axis('off')
plt.tight_layout()
plt.savefig("Hojas_enfermas/Sample.jpg")
plt.close()

IMG_SIZE = 224
BATCH_SIZE = 32
NUM_CLASSES = info.features['label'].num_classes

def preprocess(image, label):
    image = tf.image.resize(image, (IMG_SIZE, IMG_SIZE))
    image = preprocess_input(image)
    return image, label

dataset = dataset.map(preprocess, num_parallel_calls=tf.data.AUTOTUNE)
dataset = dataset.shuffle(1000, seed=123)

# Separaci칩n del datasert en conjuntos de entrenamiento, validaci칩n y prueba
total_size = info.splits['train'].num_examples
train_size = int(0.8 * total_size)
val_size = int(0.1 * total_size)
test_size = total_size - train_size - val_size

train_dataset = dataset.take(train_size)
val_dataset = dataset.skip(train_size).take(val_size)
test_dataset = dataset.skip(train_size + val_size)

train_dataset = train_dataset.batch(BATCH_SIZE).prefetch(tf.data.AUTOTUNE)
val_dataset = val_dataset.batch(BATCH_SIZE).prefetch(tf.data.AUTOTUNE)
test_dataset = test_dataset.batch(BATCH_SIZE).prefetch(tf.data.AUTOTUNE)

base_model = MobileNetV2(input_shape=(IMG_SIZE, IMG_SIZE, 3),
                         include_top=False,
                         weights='imagenet')

base_model.trainable = False  # congelamos el backbone

model = models.Sequential([
    base_model,
    layers.GlobalAveragePooling2D(),
    layers.Dropout(0.3),
    layers.Dense(NUM_CLASSES, activation='softmax')
])

model.compile(optimizer='adam',
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'])

model.summary()

early_stop = EarlyStopping(monitor='val_loss', patience=5, restore_best_weights=True)

history = model.fit(train_dataset,
                    validation_data=val_dataset,
                    epochs=20,
                    callbacks=[early_stop])

plt.figure(figsize=(10, 6))
plt.subplot(1, 2, 1)
plt.plot(history.history['accuracy'], label='Training Accuracy')
plt.plot(history.history['val_accuracy'], label='Validation Accuracy')
plt.xlabel('Epoch')
plt.ylabel('Value')
plt.title('Accuracy')
plt.grid(True)
plt.legend()

plt.subplot(1, 2, 2)
plt.plot(history.history['loss'], label='Training Loss')
plt.plot(history.history['val_loss'], label='Validation Loss')
plt.xlabel('Epoch')
plt.ylabel('Value')
plt.title('Loss')
plt.grid(True)
plt.legend()

plt.tight_layout()
plt.savefig('Hojas_enfermas/Loss_Accuracy.jpg')
plt.close()

loss, acc = model.evaluate(test_dataset)
print(f"Accuracy for test dataset: {acc * 100:.2f}%")

# Obtener predicciones y valores reales
y_pred = []
y_true = []
y_score = []

for images, labels in test_dataset:
    probs = model.predict(images)
    preds = np.argmax(probs, axis=1)
    
    y_pred.extend(preds)
    y_true.extend(labels.numpy())
    y_score.extend(probs)

y_pred = np.array(y_pred)
y_true = np.array(y_true)
y_score = np.array(y_score)

y_true_bin = label_binarize(y_true, classes=list(range(NUM_CLASSES)))

# Calcular y mostrar matriz de confusi칩n
con = confusion_matrix(y_true, y_pred)
disp = ConfusionMatrixDisplay(confusion_matrix=con)
disp.plot()
plt.savefig('Hojas_enfermas/Confusion_matrix.jpg')
plt.close()

# Diccionarios para curvas
fpr = dict()
tpr = dict()
roc_auc = dict()

for i in range(NUM_CLASSES):
    fpr[i], tpr[i], _ = roc_curve(y_true_bin[:, i], y_score[:, i])
    roc_auc[i] = auc(fpr[i], tpr[i])

plt.figure(figsize=(10, 8))

for i in range(NUM_CLASSES):
    plt.plot(fpr[i], tpr[i], label=f'Clase {i} (AUC = {roc_auc[i]:.2f})')

plt.plot([0, 1], [0, 1], 'r--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positives Rate (FPR)')
plt.ylabel('True Positives Rate (TPR)')
plt.title('Class ROC')
plt.legend(loc='lower right')
plt.grid(True)
plt.tight_layout()
plt.savefig('Hojas_enfermas/ROC_multiclass.jpg')
plt.close()

# Guardar el modelo en formato H5
model.save('Hojas_enfermas/model.h5')

# Convertir el modelo a formato TensorFlow Lite
converter = tf.lite.TFLiteConverter.from_keras_model(model)
tflite_model = converter.convert()

# Guardar el modelo TFLite
with open('Hojas_enfermas/model.tflite', 'wb') as f:
    f.write(tflite_model)